import axios from 'axios';
import type { CVE } from './db.js';

// Interface for NIST API response structure
interface NistCVEResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  format: string;
  version: string;
  timestamp: string;
  vulnerabilities: NistVulnerability[];
}

interface NistVulnerability {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        source: string;
        type: string;
        cvssData: {
          version: string;
          vectorString: string;
          attackVector: string;
          attackComplexity: string;
          privilegesRequired: string;
          userInteraction: string;
          scope: string;
          confidentialityImpact: string;
          integrityImpact: string;
          availabilityImpact: string;
          baseScore: number;
          baseSeverity: string;
        };
        exploitabilityScore: number;
        impactScore: number;
      }>;
      cvssMetricV30?: Array<{
        source: string;
        type: string;
        cvssData: {
          version: string;
          vectorString: string;
          attackVector: string;
          attackComplexity: string;
          privilegesRequired: string;
          userInteraction: string;
          scope: string;
          confidentialityImpact: string;
          integrityImpact: string;
          availabilityImpact: string;
          baseScore: number;
          baseSeverity: string;
        };
        exploitabilityScore: number;
        impactScore: number;
      }>;
      cvssMetricV2?: Array<{
        source: string;
        type: string;
        cvssData: {
          version: string;
          vectorString: string;
          accessVector: string;
          accessComplexity: string;
          authentication: string;
          confidentialityImpact: string;
          integrityImpact: string;
          availabilityImpact: string;
          baseScore: number;
        };
        baseSeverity: string;
        exploitabilityScore: number;
        impactScore: number;
        acInsufInfo: boolean;
        obtainAllPrivilege: boolean;
        obtainUserPrivilege: boolean;
        obtainOtherPrivilege: boolean;
        userInteractionRequired: boolean;
      }>;
    };
    weaknesses?: Array<{
      source: string;
      type: string;
      description: Array<{
        lang: string;
        value: string;
      }>;
    }>;
    configurations?: Array<{
      nodes: Array<{
        operator: string;
        negate: boolean;
        cpeMatch: Array<{
          vulnerable: boolean;
          criteria: string;
          matchCriteriaId: string;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
      tags?: string[];
    }>;
  };
}

// Custom error class for CVE service errors
export class CVEServiceError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'CVEServiceError';
  }
}

// Extract description from NIST API response
function extractDescription(descriptions: Array<{ lang: string; value: string }>): string {
  const englishDesc = descriptions?.find(desc => desc.lang === 'en');
  if (englishDesc) {
    return englishDesc.value;
  }

  if (descriptions && descriptions.length > 0) {
    return descriptions[0]?.value || 'No description available';
  }

  return 'No description available';
}

// Extract CVSS score and severity from metrics
function extractCVSSData(metrics?: NistVulnerability['cve']['metrics']): { score: number; severity: string } {
  if (!metrics) {
    return { score: 0.0, severity: 'UNKNOWN' };
  }

  // Try CVSS v3.1 first
  if (metrics.cvssMetricV31 && metrics.cvssMetricV31.length > 0) {
    const cvss31 = metrics.cvssMetricV31[0];
    if (cvss31?.cvssData) {
      return {
        score: cvss31.cvssData.baseScore,
        severity: cvss31.cvssData.baseSeverity.toUpperCase()
      };
    }
  }

  // Try CVSS v3.0
  if (metrics.cvssMetricV30 && metrics.cvssMetricV30.length > 0) {
    const cvss30 = metrics.cvssMetricV30[0];
    if (cvss30?.cvssData) {
      return {
        score: cvss30.cvssData.baseScore,
        severity: cvss30.cvssData.baseSeverity.toUpperCase()
      };
    }
  }

  // Fallback to CVSS v2
  if (metrics.cvssMetricV2 && metrics.cvssMetricV2.length > 0) {
    const cvss2 = metrics.cvssMetricV2[0];
    if (cvss2?.cvssData && cvss2?.baseSeverity) {
      return {
        score: cvss2.cvssData.baseScore,
        severity: cvss2.baseSeverity.toUpperCase()
      };
    }
  }

  return { score: 0.0, severity: 'UNKNOWN' };
}

// Transform NIST API response to database schema
function transformNistCVEToDB(nistVuln: NistVulnerability): CVE {
  const { cve } = nistVuln;
  const description = extractDescription(cve.descriptions);
  const { score, severity } = extractCVSSData(cve.metrics);

  return {
    cve_id: cve.id,
    description,
    severity,
    published_date: cve.published,
    modified_date: cve.lastModified,
    cvss_score: score,
    raw_data: JSON.stringify(nistVuln)
  };
}

// Main function to fetch CVEs from NIST API
export async function fetchCVEsFromAPI(): Promise<CVE[]> {
  try {
    const apiUrl = process.env.NIST_API_URL;

    if (!apiUrl) {
      throw new CVEServiceError('NIST_API_URL environment variable is not set');
    }

    console.log('Fetching CVE data from NIST API...');

    const response = await axios.get<NistCVEResponse>(apiUrl, {
      timeout: 30000,
      headers: {
        'User-Agent': 'CVE-Tracker/1.0'
      }
    });

    if (!response.data || typeof response.data !== 'object') {
      throw new CVEServiceError('Invalid response format from NIST API');
    }

    const { vulnerabilities } = response.data;

    if (!Array.isArray(vulnerabilities)) {
      throw new CVEServiceError('Invalid vulnerabilities data from NIST API');
    }

    console.log(`Received ${vulnerabilities.length} vulnerabilities from NIST API`);

    const transformedCVEs: CVE[] = [];

    for (const vulnerability of vulnerabilities) {
      try {
        const transformedCVE = transformNistCVEToDB(vulnerability);
        transformedCVEs.push(transformedCVE);
      } catch (error) {
        console.warn(`Failed to transform CVE ${vulnerability.cve?.id || 'unknown'}:`, error);
      }
    }

    console.log(`Successfully transformed ${transformedCVEs.length} CVEs`);
    return transformedCVEs;

  } catch (error) {
    if (axios.isAxiosError(error)) {
      if (error.code === 'ECONNABORTED') {
        throw new CVEServiceError('Request timeout while fetching CVE data from NIST API', 408, error);
      }

      if (error.response) {
        throw new CVEServiceError(
          `NIST API returned error: ${error.response.status} ${error.response.statusText}`,
          error.response.status,
          error
        );
      }

      if (error.request) {
        throw new CVEServiceError('Network error while connecting to NIST API', 503, error);
      }
    }

    if (error instanceof CVEServiceError) {
      throw error;
    }

    throw new CVEServiceError(
      `Unexpected error while fetching CVE data: ${error instanceof Error ? error.message : 'Unknown error'}`,
      500,
      error instanceof Error ? error : undefined
    );
  }
}