import axios from 'axios';
import type { CVE } from './db.js';

// Interface for NIST API response structure
interface NistCVEResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  format: string;
  version: string;
  timestamp: string;
  vulnerabilities: NistVulnerability[];
}

interface NistVulnerability {
  cve: {
    id: string;
    sourceIdentifier: string;
    published: string;
    lastModified: string;
    vulnStatus: string;
    descriptions: Array<{
      lang: string;
      value: string;
    }>;
    metrics?: {
      cvssMetricV31?: Array<{
        source: string;
        type: string;
        cvssData: {
          version: string;
          vectorString: string;
          attackVector: string;
          attackComplexity: string;
          privilegesRequired: string;
          userInteraction: string;
          scope: string;
          confidentialityImpact: string;
          integrityImpact: string;
          availabilityImpact: string;
          baseScore: number;
          baseSeverity: string;
        };
        exploitabilityScore: number;
        impactScore: number;
      }>;
      cvssMetricV30?: Array<{
        source: string;
        type: string;
        cvssData: {
          version: string;
          vectorString: string;
          attackVector: string;
          attackComplexity: string;
          privilegesRequired: string;
          userInteraction: string;
          scope: string;
          confidentialityImpact: string;
          integrityImpact: string;
          availabilityImpact: string;
          baseScore: number;
          baseSeverity: string;
        };
        exploitabilityScore: number;
        impactScore: number;
      }>;
      cvssMetricV2?: Array<{
        source: string;
        type: string;
        cvssData: {
          version: string;
          vectorString: string;
          accessVector: string;
          accessComplexity: string;
          authentication: string;
          confidentialityImpact: string;
          integrityImpact: string;
          availabilityImpact: string;
          baseScore: number;
        };
        baseSeverity: string;
        exploitabilityScore: number;
        impactScore: number;
        acInsufInfo: boolean;
        obtainAllPrivilege: boolean;
        obtainUserPrivilege: boolean;
        obtainOtherPrivilege: boolean;
        userInteractionRequired: boolean;
      }>;
    };
    weaknesses?: Array<{
      source: string;
      type: string;
      description: Array<{
        lang: string;
        value: string;
      }>;
    }>;
    configurations?: Array<{
      nodes: Array<{
        operator: string;
        negate: boolean;
        cpeMatch: Array<{
          vulnerable: boolean;
          criteria: string;
          matchCriteriaId: string;
        }>;
      }>;
    }>;
    references?: Array<{
      url: string;
      source: string;
      tags?: string[];
    }>;
  };
}

// Custom error class for CVE service errors
export class CVEServiceError extends Error {
  constructor(
    message: string,
    public statusCode?: number,
    public originalError?: Error
  ) {
    super(message);
    this.name = 'CVEServiceError';
  }
}

// Interface for pagination configuration
export interface PaginationConfig {
  startIndex: number;
  resultsPerPage: number;
}

// Interface for chunk fetch result
export interface ChunkResult {
  cves: CVE[];
  totalResults: number;
  startIndex: number;
  resultsPerPage: number;
  hasMoreResults: boolean;
}

// Extract description from NIST API response
function extractDescription(descriptions: Array<{ lang: string; value: string }>): string {
  const englishDesc = descriptions?.find(desc => desc.lang === 'en');
  if (englishDesc) {
    return englishDesc.value;
  }

  if (descriptions && descriptions.length > 0) {
    return descriptions[0]?.value || 'No description available';
  }

  return 'No description available';
}

// Extract CVSS score and severity from metrics
function extractCVSSData(metrics?: NistVulnerability['cve']['metrics']): { score: number; severity: string } {
  if (!metrics) {
    return { score: 0.0, severity: 'UNKNOWN' };
  }

  // Try CVSS v3.1 first
  if (metrics.cvssMetricV31 && metrics.cvssMetricV31.length > 0) {
    const cvss31 = metrics.cvssMetricV31[0];
    if (cvss31?.cvssData) {
      return {
        score: cvss31.cvssData.baseScore,
        severity: cvss31.cvssData.baseSeverity.toUpperCase()
      };
    }
  }

  // Try CVSS v3.0
  if (metrics.cvssMetricV30 && metrics.cvssMetricV30.length > 0) {
    const cvss30 = metrics.cvssMetricV30[0];
    if (cvss30?.cvssData) {
      return {
        score: cvss30.cvssData.baseScore,
        severity: cvss30.cvssData.baseSeverity.toUpperCase()
      };
    }
  }

  // Fallback to CVSS v2
  if (metrics.cvssMetricV2 && metrics.cvssMetricV2.length > 0) {
    const cvss2 = metrics.cvssMetricV2[0];
    if (cvss2?.cvssData && cvss2?.baseSeverity) {
      return {
        score: cvss2.cvssData.baseScore,
        severity: cvss2.baseSeverity.toUpperCase()
      };
    }
  }

  return { score: 0.0, severity: 'UNKNOWN' };
}

// Transform NIST API response to database schema
function transformNistCVEToDB(nistVuln: NistVulnerability): CVE {
  const { cve } = nistVuln;
  const description = extractDescription(cve.descriptions);
  const { score, severity } = extractCVSSData(cve.metrics);

  return {
    cve_id: cve.id,
    description,
    severity,
    published_date: cve.published,
    modified_date: cve.lastModified,
    cvss_score: score,
    raw_data: JSON.stringify(nistVuln)
  };
}

// Fetch a single chunk of CVEs with pagination
export async function fetchCVEChunk(baseApiUrl: string, pagination: PaginationConfig): Promise<ChunkResult> {
  try {
    const url = new URL(baseApiUrl);
    url.searchParams.set('startIndex', pagination.startIndex.toString());
    url.searchParams.set('resultsPerPage', pagination.resultsPerPage.toString());

    console.log(`Fetching CVE chunk: startIndex=${pagination.startIndex}, resultsPerPage=${pagination.resultsPerPage}`);

    const response = await axios.get<NistCVEResponse>(url.toString(), {
      timeout: 30000,
      headers: {
        'User-Agent': 'CVE-Tracker/1.0'
      }
    });

    if (!response.data || typeof response.data !== 'object') {
      throw new CVEServiceError('Invalid response format from NIST API');
    }

    const { vulnerabilities, totalResults, startIndex, resultsPerPage } = response.data;

    if (!Array.isArray(vulnerabilities)) {
      throw new CVEServiceError('Invalid vulnerabilities data from NIST API');
    }

    console.log(`Received ${vulnerabilities.length} vulnerabilities from NIST API (${startIndex} to ${startIndex + vulnerabilities.length - 1} of ${totalResults})`);

    const transformedCVEs: CVE[] = [];

    for (const vulnerability of vulnerabilities) {
      try {
        const transformedCVE = transformNistCVEToDB(vulnerability);
        transformedCVEs.push(transformedCVE);
      } catch (error) {
        console.warn(`Failed to transform CVE ${vulnerability.cve?.id || 'unknown'}:`, error);
      }
    }

    const hasMoreResults = (startIndex + vulnerabilities.length) < totalResults;

    return {
      cves: transformedCVEs,
      totalResults,
      startIndex,
      resultsPerPage,
      hasMoreResults
    };

  } catch (error) {
    if (axios.isAxiosError(error)) {
      if (error.code === 'ECONNABORTED') {
        throw new CVEServiceError('Request timeout while fetching CVE data from NIST API', 408, error);
      }

      if (error.response) {
        throw new CVEServiceError(
          `NIST API returned error: ${error.response.status} ${error.response.statusText}`,
          error.response.status,
          error
        );
      }

      if (error.request) {
        throw new CVEServiceError('Network error while connecting to NIST API', 503, error);
      }
    }

    if (error instanceof CVEServiceError) {
      throw error;
    }

    throw new CVEServiceError(
      `Unexpected error while fetching CVE chunk: ${error instanceof Error ? error.message : 'Unknown error'}`,
      500,
      error instanceof Error ? error : undefined
    );
  }
}

// Fetch all CVEs in chunks with progress callback
export async function fetchAllCVEsInChunks(
  apiUrl?: string,
  chunkSize: number = 2000,
  onProgress?: (progress: { current: number; total: number; percentage: number; cves: CVE[] }) => void
): Promise<CVE[]> {
  const nistApiUrl = apiUrl || process.env.NIST_API_URL || 'https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=cpe:2.3:o:microsoft:windows_10:1607';

  if (!nistApiUrl) {
    throw new CVEServiceError('NIST_API_URL environment variable is not set');
  }

  const allCVEs: CVE[] = [];
  let startIndex = 0;
  let totalResults = 0;
  let hasMoreResults = true;

  console.log('Starting chunked CVE fetch...');

  while (hasMoreResults) {
    try {
      const chunkResult = await fetchCVEChunk(nistApiUrl, {
        startIndex,
        resultsPerPage: Math.min(chunkSize, 2000) // NIST API max is 2000
      });

      allCVEs.push(...chunkResult.cves);
      totalResults = chunkResult.totalResults;
      hasMoreResults = chunkResult.hasMoreResults;

      if (onProgress) {
        const percentage = totalResults > 0 ? Math.round((allCVEs.length / totalResults) * 100) : 0;
        onProgress({
          current: allCVEs.length,
          total: totalResults,
          percentage,
          cves: [...chunkResult.cves] // Send only the new CVEs in this chunk
        });
      }

      startIndex += chunkResult.cves.length;

      // Add a small delay to be respectful to the API
      if (hasMoreResults) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }

    } catch (error) {
      console.error(`Error fetching chunk starting at ${startIndex}:`, error);
      throw error;
    }
  }

  console.log(`Completed chunked fetch: ${allCVEs.length} CVEs retrieved`);
  return allCVEs;
}

// Main function to fetch CVEs from NIST API (backward compatibility)
export async function fetchCVEsFromAPI(apiUrl?: string): Promise<CVE[]> {
  return fetchAllCVEsInChunks(apiUrl, 2000);
}